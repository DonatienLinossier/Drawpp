# ============================
# AUTO-GENERATED CODE: NODE DEFINITIONS CLASSES DEFINED IN nodedefs.py
# This file contains the generated classes issued from the nodedefs.py file.
# It is generated by the codegen.py module.
# ============================

from pydpp.compiler.syntax.base import *
from pydpp.compiler.tokenizer import Token, TokenKind
import pydpp.compiler.syntax.genext as genext
from typing import Iterable

class BuiltInType(Statement):
    """
    A built-in type specified using a keyword like int, bool...
    """
    __slots__ = ('_kind_token', )

    kind_token_slot: SingleNodeSlot["BuiltInType", LeafNode] = SingleNodeSlot('_kind_token', LeafNode)
    "The token representing the type."

    def __init__(self, kind_token: LeafNode | None):
        super().__init__()
        assert kind_token is None or BuiltInType.kind_token_slot.accepts(kind_token)
        self._kind_token = kind_token
        if kind_token is not None: 
            kind_token.register_attachment(self, BuiltInType.kind_token_slot)
            if kind_token.has_problems: self._update_has_problems(True)


    @property
    def kind_token(self) -> LeafNode | None:
        """
        The token representing the type.
        """
        return self._kind_token

    @kind_token.setter
    def kind_token(self, value: LeafNode | None):
        if value is not None: 
            self._kind_token = self.attach_child(self.kind_token_slot, value)
        else:
            self.detach_child(self.kind_token_slot)

    @property
    def children(self):
        if self._kind_token is not None: yield self._kind_token

    @property
    def children_reversed(self):
        if self._kind_token is not None: yield self._kind_token

    @property
    def child_inner_nodes(self):
        return []

BuiltInType.element_slots = (BuiltInType.kind_token_slot, )
BuiltInType.inner_node_slots = ()


class Argument(InnerNode):
    """
    An argument to a function call.
    Example: 8, 2, my_func(840), "artichaut"
    """
    __slots__ = ('_expr', '_comma_token', )

    expr_slot: SingleNodeSlot["Argument", Expression] = SingleNodeSlot('_expr', Expression)
    "The expression representing the argument."
    comma_token_slot: SingleNodeSlot["Argument", LeafNode] = SingleNodeSlot('_comma_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_COMMA)
    "The ',' token."

    def __init__(self, expr: Expression | None, comma_token: LeafNode | None):
        super().__init__()
        assert expr is None or Argument.expr_slot.accepts(expr)
        self._expr = expr
        if expr is not None: 
            expr.register_attachment(self, Argument.expr_slot)
            if expr.has_problems: self._update_has_problems(True)

        assert comma_token is None or Argument.comma_token_slot.accepts(comma_token)
        self._comma_token = comma_token
        if comma_token is not None: 
            comma_token.register_attachment(self, Argument.comma_token_slot)
            if comma_token.has_problems: self._update_has_problems(True)


    @property
    def expr(self) -> Expression | None:
        """
        The expression representing the argument.
        """
        return self._expr

    @expr.setter
    def expr(self, value: Expression | None):
        if value is not None: 
            self._expr = self.attach_child(self.expr_slot, value)
        else:
            self.detach_child(self.expr_slot)

    @property
    def comma_token(self) -> LeafNode | None:
        """
        The ',' token.
        """
        return self._comma_token

    @comma_token.setter
    def comma_token(self, value: LeafNode | None):
        if value is not None: 
            self._comma_token = self.attach_child(self.comma_token_slot, value)
        else:
            self.detach_child(self.comma_token_slot)

    @property
    def children(self):
        if self._expr is not None: yield self._expr
        if self._comma_token is not None: yield self._comma_token

    @property
    def children_reversed(self):
        if self._comma_token is not None: yield self._comma_token
        if self._expr is not None: yield self._expr

    @property
    def child_inner_nodes(self):
        if self._expr is not None: yield self._expr

Argument.element_slots = (Argument.expr_slot, Argument.comma_token_slot, )
Argument.inner_node_slots = (Argument.expr_slot, )


class ArgumentList(InnerNode):
    """
    A list of arguments to a function call.
    """
    __slots__ = ('_lparen_token', '_arguments', '_rparen_token', )

    lparen_token_slot: SingleNodeSlot["ArgumentList", LeafNode] = SingleNodeSlot('_lparen_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_LPAREN)
    "The '(' token."
    arguments_slot: MultiNodeSlot["ArgumentList", Argument] = MultiNodeSlot('_arguments', Argument)
    "The arguments to the function."
    rparen_token_slot: SingleNodeSlot["ArgumentList", LeafNode] = SingleNodeSlot('_rparen_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_RPAREN)
    "The ')' token."

    def __init__(self, lparen_token: LeafNode | None, arguments: Iterable[Argument], rparen_token: LeafNode | None):
        super().__init__()
        assert lparen_token is None or ArgumentList.lparen_token_slot.accepts(lparen_token)
        self._lparen_token = lparen_token
        if lparen_token is not None: 
            lparen_token.register_attachment(self, ArgumentList.lparen_token_slot)
            if lparen_token.has_problems: self._update_has_problems(True)

        self._arguments = list(arguments)
        for s_init_el in self._arguments:
            assert s_init_el is not None and ArgumentList.arguments_slot.accepts(s_init_el)
            s_init_el.register_attachment(self, ArgumentList.arguments_slot)
            if s_init_el.has_problems: self._update_has_problems(True)

        assert rparen_token is None or ArgumentList.rparen_token_slot.accepts(rparen_token)
        self._rparen_token = rparen_token
        if rparen_token is not None: 
            rparen_token.register_attachment(self, ArgumentList.rparen_token_slot)
            if rparen_token.has_problems: self._update_has_problems(True)


    @property
    def lparen_token(self) -> LeafNode | None:
        """
        The '(' token.
        """
        return self._lparen_token

    @lparen_token.setter
    def lparen_token(self, value: LeafNode | None):
        if value is not None: 
            self._lparen_token = self.attach_child(self.lparen_token_slot, value)
        else:
            self.detach_child(self.lparen_token_slot)

    @property
    def arguments(self) -> Iterable[Argument]:
        """
        The arguments to the function.
        """
        return self._arguments

    @property
    def rparen_token(self) -> LeafNode | None:
        """
        The ')' token.
        """
        return self._rparen_token

    @rparen_token.setter
    def rparen_token(self, value: LeafNode | None):
        if value is not None: 
            self._rparen_token = self.attach_child(self.rparen_token_slot, value)
        else:
            self.detach_child(self.rparen_token_slot)

    @property
    def children(self):
        if self._lparen_token is not None: yield self._lparen_token
        yield from self._arguments
        if self._rparen_token is not None: yield self._rparen_token

    @property
    def children_reversed(self):
        if self._rparen_token is not None: yield self._rparen_token
        yield from reversed(self._arguments)
        if self._lparen_token is not None: yield self._lparen_token

    @property
    def child_inner_nodes(self):
        return self._arguments

ArgumentList.element_slots = (ArgumentList.lparen_token_slot, ArgumentList.arguments_slot, ArgumentList.rparen_token_slot, )
ArgumentList.inner_node_slots = (ArgumentList.arguments_slot, )


class FunctionParameter(InnerNode):
    """
    A parameter defined within a function (fct).
    Example: int x
    """
    __slots__ = ('_type', '_name_token', '_comma', )

    type_slot: SingleNodeSlot["FunctionParameter", BuiltInType] = SingleNodeSlot('_type', BuiltInType)
    "The type of the parameter."
    name_token_slot: SingleNodeSlot["FunctionParameter", LeafNode] = SingleNodeSlot('_name_token', LeafNode, check_func=lambda x: x.kind == TokenKind.IDENTIFIER)
    "The name of the parameter."
    comma_slot: SingleNodeSlot["FunctionParameter", LeafNode] = SingleNodeSlot('_comma', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_COMMA)
    "The ',' token, when inside a list of function parameters."

    def __init__(self, type: BuiltInType | None, name_token: LeafNode | None, comma: LeafNode | None):
        super().__init__()
        assert type is None or FunctionParameter.type_slot.accepts(type)
        self._type = type
        if type is not None: 
            type.register_attachment(self, FunctionParameter.type_slot)
            if type.has_problems: self._update_has_problems(True)

        assert name_token is None or FunctionParameter.name_token_slot.accepts(name_token)
        self._name_token = name_token
        if name_token is not None: 
            name_token.register_attachment(self, FunctionParameter.name_token_slot)
            if name_token.has_problems: self._update_has_problems(True)

        assert comma is None or FunctionParameter.comma_slot.accepts(comma)
        self._comma = comma
        if comma is not None: 
            comma.register_attachment(self, FunctionParameter.comma_slot)
            if comma.has_problems: self._update_has_problems(True)


    @property
    def type(self) -> BuiltInType | None:
        """
        The type of the parameter.
        """
        return self._type

    @type.setter
    def type(self, value: BuiltInType | None):
        if value is not None: 
            self._type = self.attach_child(self.type_slot, value)
        else:
            self.detach_child(self.type_slot)

    @property
    def name_token(self) -> LeafNode | None:
        """
        The name of the parameter.
        """
        return self._name_token

    @name_token.setter
    def name_token(self, value: LeafNode | None):
        if value is not None: 
            self._name_token = self.attach_child(self.name_token_slot, value)
        else:
            self.detach_child(self.name_token_slot)

    @property
    def name_token_str(self) -> str:
        """
        The name of the parameter.
        """
        return self._name_token.text

    @property
    def comma(self) -> LeafNode | None:
        """
        The ',' token, when inside a list of function parameters.
        """
        return self._comma

    @comma.setter
    def comma(self, value: LeafNode | None):
        if value is not None: 
            self._comma = self.attach_child(self.comma_slot, value)
        else:
            self.detach_child(self.comma_slot)

    @property
    def children(self):
        if self._type is not None: yield self._type
        if self._name_token is not None: yield self._name_token
        if self._comma is not None: yield self._comma

    @property
    def children_reversed(self):
        if self._comma is not None: yield self._comma
        if self._name_token is not None: yield self._name_token
        if self._type is not None: yield self._type

    @property
    def child_inner_nodes(self):
        if self._type is not None: yield self._type

FunctionParameter.element_slots = (FunctionParameter.type_slot, FunctionParameter.name_token_slot, FunctionParameter.comma_slot, )
FunctionParameter.inner_node_slots = (FunctionParameter.type_slot, )


class LiteralExpr(Expression):
    """
    A literal expression, which can be either:
        - a number literal (5, 3.14)
        - a string literal ("hello, world!")
        - a boolean literal (true, false)
    
    The value of the literal is contained within the token: token.value
    """
    __slots__ = ('_token', )

    token_slot: SingleNodeSlot["LiteralExpr", LeafNode] = SingleNodeSlot('_token', LeafNode, check_func=lambda x: x.kind in {TokenKind.LITERAL_NUM, TokenKind.LITERAL_STRING, TokenKind.LITERAL_BOOL}, optional=False)
    "The token representing the literal."

    def __init__(self, token: LeafNode):
        super().__init__()
        assert token is not None and LiteralExpr.token_slot.accepts(token)
        self._token = token
        token.register_attachment(self, LiteralExpr.token_slot)
        if token.has_problems: self._update_has_problems(True)


    @property
    def token(self) -> LeafNode:
        """
        The token representing the literal.
        """
        return self._token

    @token.setter
    def token(self, value: LeafNode):
        self._token = self.attach_child(self.token_slot, value)

    @property
    def children(self):
        yield self._token

    @property
    def children_reversed(self):
        yield self._token

    @property
    def child_inner_nodes(self):
        return []

LiteralExpr.element_slots = (LiteralExpr.token_slot, )
LiteralExpr.inner_node_slots = ()


class BinaryOperationExpr(Expression):
    """
    A binary operation expression, following this pattern: left [operator] right.
    Where [operator] is a binary operator in the ``BinaryOperator`` enum.
    
    Examples:
        - 5 + 8 ; left = 5, operator = ADD, right = 8
        - 8 * 6 ; left = 8, operator = MUL, right = 6
    """
    __slots__ = ('_left', '_operator_token', '_right', )

    left_slot: SingleNodeSlot["BinaryOperationExpr", Expression] = SingleNodeSlot('_left', Expression)
    "The left side of the operation."
    operator_token_slot: SingleNodeSlot["BinaryOperationExpr", LeafNode] = SingleNodeSlot('_operator_token', LeafNode, check_func=lambda x: x.kind in {TokenKind.KW_OR, TokenKind.KW_AND, TokenKind.SYM_EQ, TokenKind.SYM_NEQ, TokenKind.SYM_LT, TokenKind.SYM_LEQ, TokenKind.SYM_GT, TokenKind.SYM_GEQ, TokenKind.SYM_PLUS, TokenKind.SYM_MINUS, TokenKind.SYM_STAR, TokenKind.SYM_SLASH})
    "The operator token."
    right_slot: SingleNodeSlot["BinaryOperationExpr", Expression] = SingleNodeSlot('_right', Expression)
    "The right side of the operation."

    def __init__(self, left: Expression | None, operator_token: LeafNode | None, right: Expression | None):
        super().__init__()
        assert left is None or BinaryOperationExpr.left_slot.accepts(left)
        self._left = left
        if left is not None: 
            left.register_attachment(self, BinaryOperationExpr.left_slot)
            if left.has_problems: self._update_has_problems(True)

        assert operator_token is None or BinaryOperationExpr.operator_token_slot.accepts(operator_token)
        self._operator_token = operator_token
        if operator_token is not None: 
            operator_token.register_attachment(self, BinaryOperationExpr.operator_token_slot)
            if operator_token.has_problems: self._update_has_problems(True)

        assert right is None or BinaryOperationExpr.right_slot.accepts(right)
        self._right = right
        if right is not None: 
            right.register_attachment(self, BinaryOperationExpr.right_slot)
            if right.has_problems: self._update_has_problems(True)


    @property
    def left(self) -> Expression | None:
        """
        The left side of the operation.
        """
        return self._left

    @left.setter
    def left(self, value: Expression | None):
        if value is not None: 
            self._left = self.attach_child(self.left_slot, value)
        else:
            self.detach_child(self.left_slot)

    @property
    def operator_token(self) -> LeafNode | None:
        """
        The operator token.
        """
        return self._operator_token

    @operator_token.setter
    def operator_token(self, value: LeafNode | None):
        if value is not None: 
            self._operator_token = self.attach_child(self.operator_token_slot, value)
        else:
            self.detach_child(self.operator_token_slot)

    @property
    def right(self) -> Expression | None:
        """
        The right side of the operation.
        """
        return self._right

    @right.setter
    def right(self, value: Expression | None):
        if value is not None: 
            self._right = self.attach_child(self.right_slot, value)
        else:
            self.detach_child(self.right_slot)

    @property
    def children(self):
        if self._left is not None: yield self._left
        if self._operator_token is not None: yield self._operator_token
        if self._right is not None: yield self._right

    @property
    def children_reversed(self):
        if self._right is not None: yield self._right
        if self._operator_token is not None: yield self._operator_token
        if self._left is not None: yield self._left

    @property
    def child_inner_nodes(self):
        if self._left is not None: yield self._left
        if self._right is not None: yield self._right

BinaryOperationExpr.element_slots = (BinaryOperationExpr.left_slot, BinaryOperationExpr.operator_token_slot, BinaryOperationExpr.right_slot, )
BinaryOperationExpr.inner_node_slots = (BinaryOperationExpr.left_slot, BinaryOperationExpr.right_slot, )


class ParenthesizedExpr(Expression):
    """
    An expression enclosed in parentheses.
    """
    __slots__ = ('_lparen_token', '_expr', '_rparen_token', )

    lparen_token_slot: SingleNodeSlot["ParenthesizedExpr", LeafNode] = SingleNodeSlot('_lparen_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_LPAREN)
    "The '(' token."
    expr_slot: SingleNodeSlot["ParenthesizedExpr", Expression] = SingleNodeSlot('_expr', Expression)
    "The expression inside the parentheses."
    rparen_token_slot: SingleNodeSlot["ParenthesizedExpr", LeafNode] = SingleNodeSlot('_rparen_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_RPAREN)
    "The ')' token."

    def __init__(self, lparen_token: LeafNode | None, expr: Expression | None, rparen_token: LeafNode | None):
        super().__init__()
        assert lparen_token is None or ParenthesizedExpr.lparen_token_slot.accepts(lparen_token)
        self._lparen_token = lparen_token
        if lparen_token is not None: 
            lparen_token.register_attachment(self, ParenthesizedExpr.lparen_token_slot)
            if lparen_token.has_problems: self._update_has_problems(True)

        assert expr is None or ParenthesizedExpr.expr_slot.accepts(expr)
        self._expr = expr
        if expr is not None: 
            expr.register_attachment(self, ParenthesizedExpr.expr_slot)
            if expr.has_problems: self._update_has_problems(True)

        assert rparen_token is None or ParenthesizedExpr.rparen_token_slot.accepts(rparen_token)
        self._rparen_token = rparen_token
        if rparen_token is not None: 
            rparen_token.register_attachment(self, ParenthesizedExpr.rparen_token_slot)
            if rparen_token.has_problems: self._update_has_problems(True)


    @property
    def lparen_token(self) -> LeafNode | None:
        """
        The '(' token.
        """
        return self._lparen_token

    @lparen_token.setter
    def lparen_token(self, value: LeafNode | None):
        if value is not None: 
            self._lparen_token = self.attach_child(self.lparen_token_slot, value)
        else:
            self.detach_child(self.lparen_token_slot)

    @property
    def expr(self) -> Expression | None:
        """
        The expression inside the parentheses.
        """
        return self._expr

    @expr.setter
    def expr(self, value: Expression | None):
        if value is not None: 
            self._expr = self.attach_child(self.expr_slot, value)
        else:
            self.detach_child(self.expr_slot)

    @property
    def rparen_token(self) -> LeafNode | None:
        """
        The ')' token.
        """
        return self._rparen_token

    @rparen_token.setter
    def rparen_token(self, value: LeafNode | None):
        if value is not None: 
            self._rparen_token = self.attach_child(self.rparen_token_slot, value)
        else:
            self.detach_child(self.rparen_token_slot)

    @property
    def children(self):
        if self._lparen_token is not None: yield self._lparen_token
        if self._expr is not None: yield self._expr
        if self._rparen_token is not None: yield self._rparen_token

    @property
    def children_reversed(self):
        if self._rparen_token is not None: yield self._rparen_token
        if self._expr is not None: yield self._expr
        if self._lparen_token is not None: yield self._lparen_token

    @property
    def child_inner_nodes(self):
        if self._expr is not None: yield self._expr

ParenthesizedExpr.element_slots = (ParenthesizedExpr.lparen_token_slot, ParenthesizedExpr.expr_slot, ParenthesizedExpr.rparen_token_slot, )
ParenthesizedExpr.inner_node_slots = (ParenthesizedExpr.expr_slot, )


class UnaryExpr(Expression):
    """
    A unary expression, an expression with a NOT/- operator before it.
    Example: NOT true
    """
    __slots__ = ('_op_token', '_expr', )

    op_token_slot: SingleNodeSlot["UnaryExpr", LeafNode] = SingleNodeSlot('_op_token', LeafNode, check_func=lambda x: x.kind in {TokenKind.KW_NOT, TokenKind.SYM_MINUS})
    "The operator preceding the expression: ."
    expr_slot: SingleNodeSlot["UnaryExpr", Expression] = SingleNodeSlot('_expr', Expression)
    "The expression to apply the operator to."

    def __init__(self, op_token: LeafNode | None, expr: Expression | None):
        super().__init__()
        assert op_token is None or UnaryExpr.op_token_slot.accepts(op_token)
        self._op_token = op_token
        if op_token is not None: 
            op_token.register_attachment(self, UnaryExpr.op_token_slot)
            if op_token.has_problems: self._update_has_problems(True)

        assert expr is None or UnaryExpr.expr_slot.accepts(expr)
        self._expr = expr
        if expr is not None: 
            expr.register_attachment(self, UnaryExpr.expr_slot)
            if expr.has_problems: self._update_has_problems(True)


    @property
    def op_token(self) -> LeafNode | None:
        """
        The operator preceding the expression: .
        """
        return self._op_token

    @op_token.setter
    def op_token(self, value: LeafNode | None):
        if value is not None: 
            self._op_token = self.attach_child(self.op_token_slot, value)
        else:
            self.detach_child(self.op_token_slot)

    @property
    def expr(self) -> Expression | None:
        """
        The expression to apply the operator to.
        """
        return self._expr

    @expr.setter
    def expr(self, value: Expression | None):
        if value is not None: 
            self._expr = self.attach_child(self.expr_slot, value)
        else:
            self.detach_child(self.expr_slot)

    @property
    def children(self):
        if self._op_token is not None: yield self._op_token
        if self._expr is not None: yield self._expr

    @property
    def children_reversed(self):
        if self._expr is not None: yield self._expr
        if self._op_token is not None: yield self._op_token

    @property
    def child_inner_nodes(self):
        if self._expr is not None: yield self._expr

UnaryExpr.element_slots = (UnaryExpr.op_token_slot, UnaryExpr.expr_slot, )
UnaryExpr.inner_node_slots = (UnaryExpr.expr_slot, )


class FunctionExpr(Expression):
    """
    A function call expression, which calls a function with a list of arguments, and gives
    the return value of the function.
    """
    __slots__ = ('_identifier_token', '_arg_list', )

    identifier_token_slot: SingleNodeSlot["FunctionExpr", LeafNode] = SingleNodeSlot('_identifier_token', LeafNode, check_func=lambda x: x.kind == TokenKind.IDENTIFIER)
    "The identifier of the function."
    arg_list_slot: SingleNodeSlot["FunctionExpr", ArgumentList] = SingleNodeSlot('_arg_list', ArgumentList)
    "The arguments to the function."

    def __init__(self, identifier_token: LeafNode | None, arg_list: ArgumentList | None):
        super().__init__()
        assert identifier_token is None or FunctionExpr.identifier_token_slot.accepts(identifier_token)
        self._identifier_token = identifier_token
        if identifier_token is not None: 
            identifier_token.register_attachment(self, FunctionExpr.identifier_token_slot)
            if identifier_token.has_problems: self._update_has_problems(True)

        assert arg_list is None or FunctionExpr.arg_list_slot.accepts(arg_list)
        self._arg_list = arg_list
        if arg_list is not None: 
            arg_list.register_attachment(self, FunctionExpr.arg_list_slot)
            if arg_list.has_problems: self._update_has_problems(True)


    @property
    def identifier_token(self) -> LeafNode | None:
        """
        The identifier of the function.
        """
        return self._identifier_token

    @identifier_token.setter
    def identifier_token(self, value: LeafNode | None):
        if value is not None: 
            self._identifier_token = self.attach_child(self.identifier_token_slot, value)
        else:
            self.detach_child(self.identifier_token_slot)

    @property
    def identifier_token_str(self) -> str:
        """
        The identifier of the function.
        """
        return self._identifier_token.text

    @property
    def arg_list(self) -> ArgumentList | None:
        """
        The arguments to the function.
        """
        return self._arg_list

    @arg_list.setter
    def arg_list(self, value: ArgumentList | None):
        if value is not None: 
            self._arg_list = self.attach_child(self.arg_list_slot, value)
        else:
            self.detach_child(self.arg_list_slot)

    @property
    def children(self):
        if self._identifier_token is not None: yield self._identifier_token
        if self._arg_list is not None: yield self._arg_list

    @property
    def children_reversed(self):
        if self._arg_list is not None: yield self._arg_list
        if self._identifier_token is not None: yield self._identifier_token

    @property
    def child_inner_nodes(self):
        if self._arg_list is not None: yield self._arg_list

FunctionExpr.element_slots = (FunctionExpr.identifier_token_slot, FunctionExpr.arg_list_slot, )
FunctionExpr.inner_node_slots = (FunctionExpr.arg_list_slot, )


class VariableExpr(Expression):
    """
    A variable expression, returning the value of a variable.
    """
    __slots__ = ('_name_token', )

    name_token_slot: SingleNodeSlot["VariableExpr", LeafNode] = SingleNodeSlot('_name_token', LeafNode, check_func=lambda x: x.kind == TokenKind.IDENTIFIER, optional=False)
    "The name of the variable."

    def __init__(self, name_token: LeafNode):
        super().__init__()
        assert name_token is not None and VariableExpr.name_token_slot.accepts(name_token)
        self._name_token = name_token
        name_token.register_attachment(self, VariableExpr.name_token_slot)
        if name_token.has_problems: self._update_has_problems(True)


    @property
    def name_token(self) -> LeafNode:
        """
        The name of the variable.
        """
        return self._name_token

    @name_token.setter
    def name_token(self, value: LeafNode):
        self._name_token = self.attach_child(self.name_token_slot, value)

    @property
    def name_token_str(self) -> str:
        """
        The name of the variable.
        """
        return self._name_token.text

    @property
    def children(self):
        yield self._name_token

    @property
    def children_reversed(self):
        yield self._name_token

    @property
    def child_inner_nodes(self):
        return []

VariableExpr.element_slots = (VariableExpr.name_token_slot, )
VariableExpr.inner_node_slots = ()


class ErrorExpr(Expression):
    """
    An invalid/unrecognized expression. Prevents compilation. Has unknown type.
    """
    __slots__ = ('_tokens', )

    tokens_slot: MultiNodeSlot["ErrorExpr", LeafNode] = MultiNodeSlot('_tokens', LeafNode)
    "All tokens that were ignored during parsing."

    def __init__(self, tokens: Iterable[LeafNode]):
        super().__init__()
        self._tokens = list(tokens)
        for s_init_el in self._tokens:
            assert s_init_el is not None and ErrorExpr.tokens_slot.accepts(s_init_el)
            s_init_el.register_attachment(self, ErrorExpr.tokens_slot)
            if s_init_el.has_problems: self._update_has_problems(True)


    @property
    def tokens(self) -> Iterable[LeafNode]:
        """
        All tokens that were ignored during parsing.
        """
        return self._tokens

    @property
    def children(self):
        yield from self._tokens

    @property
    def children_reversed(self):
        yield from reversed(self._tokens)

    @property
    def child_inner_nodes(self):
        return []

ErrorExpr.element_slots = (ErrorExpr.tokens_slot, )
ErrorExpr.inner_node_slots = ()


class BlockStmt(Statement):
    """
    A block statement, which is a sequence of statements enclosed in curly braces.
    """
    __slots__ = ('_lbrace_token', '_statements', '_rbrace_token', )

    lbrace_token_slot: SingleNodeSlot["BlockStmt", LeafNode] = SingleNodeSlot('_lbrace_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_LBRACE)
    "The '{' token."
    statements_slot: MultiNodeSlot["BlockStmt", Statement] = MultiNodeSlot('_statements', Statement)
    "The statements contained within the block."
    rbrace_token_slot: SingleNodeSlot["BlockStmt", LeafNode] = SingleNodeSlot('_rbrace_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_RBRACE)
    "The '}' token."

    def __init__(self, lbrace_token: LeafNode | None, statements: Iterable[Statement], rbrace_token: LeafNode | None):
        super().__init__()
        assert lbrace_token is None or BlockStmt.lbrace_token_slot.accepts(lbrace_token)
        self._lbrace_token = lbrace_token
        if lbrace_token is not None: 
            lbrace_token.register_attachment(self, BlockStmt.lbrace_token_slot)
            if lbrace_token.has_problems: self._update_has_problems(True)

        self._statements = list(statements)
        for s_init_el in self._statements:
            assert s_init_el is not None and BlockStmt.statements_slot.accepts(s_init_el)
            s_init_el.register_attachment(self, BlockStmt.statements_slot)
            if s_init_el.has_problems: self._update_has_problems(True)

        assert rbrace_token is None or BlockStmt.rbrace_token_slot.accepts(rbrace_token)
        self._rbrace_token = rbrace_token
        if rbrace_token is not None: 
            rbrace_token.register_attachment(self, BlockStmt.rbrace_token_slot)
            if rbrace_token.has_problems: self._update_has_problems(True)


    @property
    def lbrace_token(self) -> LeafNode | None:
        """
        The '{' token.
        """
        return self._lbrace_token

    @lbrace_token.setter
    def lbrace_token(self, value: LeafNode | None):
        if value is not None: 
            self._lbrace_token = self.attach_child(self.lbrace_token_slot, value)
        else:
            self.detach_child(self.lbrace_token_slot)

    @property
    def statements(self) -> Iterable[Statement]:
        """
        The statements contained within the block.
        """
        return self._statements

    @property
    def rbrace_token(self) -> LeafNode | None:
        """
        The '}' token.
        """
        return self._rbrace_token

    @rbrace_token.setter
    def rbrace_token(self, value: LeafNode | None):
        if value is not None: 
            self._rbrace_token = self.attach_child(self.rbrace_token_slot, value)
        else:
            self.detach_child(self.rbrace_token_slot)

    @property
    def children(self):
        if self._lbrace_token is not None: yield self._lbrace_token
        yield from self._statements
        if self._rbrace_token is not None: yield self._rbrace_token

    @property
    def children_reversed(self):
        if self._rbrace_token is not None: yield self._rbrace_token
        yield from reversed(self._statements)
        if self._lbrace_token is not None: yield self._lbrace_token

    @property
    def child_inner_nodes(self):
        return self._statements

BlockStmt.element_slots = (BlockStmt.lbrace_token_slot, BlockStmt.statements_slot, BlockStmt.rbrace_token_slot, )
BlockStmt.inner_node_slots = (BlockStmt.statements_slot, )


class FunctionDeclarationStmt(Statement):
    """
    A function declaration, with a return type, name, parameters, and a block of statements.
    Example:
        fct my_func(int a, float b) {
            say("hi");
        }
    """
    __slots__ = ('_fct_token', '_name_token', '_lparen_token', '_parameters', '_rparen_token', '_body', )

    fct_token_slot: SingleNodeSlot["FunctionDeclarationStmt", LeafNode] = SingleNodeSlot('_fct_token', LeafNode)
    "The 'fct' token."
    name_token_slot: SingleNodeSlot["FunctionDeclarationStmt", LeafNode] = SingleNodeSlot('_name_token', LeafNode, check_func=lambda x: x.kind == TokenKind.IDENTIFIER)
    "The name of the function."
    lparen_token_slot: SingleNodeSlot["FunctionDeclarationStmt", LeafNode] = SingleNodeSlot('_lparen_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_LPAREN)
    "The '(' token."
    parameters_slot: MultiNodeSlot["FunctionDeclarationStmt", FunctionParameter] = MultiNodeSlot('_parameters', FunctionParameter)
    "The parameters of the function."
    rparen_token_slot: SingleNodeSlot["FunctionDeclarationStmt", LeafNode] = SingleNodeSlot('_rparen_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_RPAREN)
    "The ')' token."
    body_slot: SingleNodeSlot["FunctionDeclarationStmt", BlockStmt] = SingleNodeSlot('_body', BlockStmt)
    "The block of statements inside the function."

    def __init__(self, fct_token: LeafNode | None, name_token: LeafNode | None, lparen_token: LeafNode | None, parameters: Iterable[FunctionParameter], rparen_token: LeafNode | None, body: BlockStmt | None):
        super().__init__()
        assert fct_token is None or FunctionDeclarationStmt.fct_token_slot.accepts(fct_token)
        self._fct_token = fct_token
        if fct_token is not None: 
            fct_token.register_attachment(self, FunctionDeclarationStmt.fct_token_slot)
            if fct_token.has_problems: self._update_has_problems(True)

        assert name_token is None or FunctionDeclarationStmt.name_token_slot.accepts(name_token)
        self._name_token = name_token
        if name_token is not None: 
            name_token.register_attachment(self, FunctionDeclarationStmt.name_token_slot)
            if name_token.has_problems: self._update_has_problems(True)

        assert lparen_token is None or FunctionDeclarationStmt.lparen_token_slot.accepts(lparen_token)
        self._lparen_token = lparen_token
        if lparen_token is not None: 
            lparen_token.register_attachment(self, FunctionDeclarationStmt.lparen_token_slot)
            if lparen_token.has_problems: self._update_has_problems(True)

        self._parameters = list(parameters)
        for s_init_el in self._parameters:
            assert s_init_el is not None and FunctionDeclarationStmt.parameters_slot.accepts(s_init_el)
            s_init_el.register_attachment(self, FunctionDeclarationStmt.parameters_slot)
            if s_init_el.has_problems: self._update_has_problems(True)

        assert rparen_token is None or FunctionDeclarationStmt.rparen_token_slot.accepts(rparen_token)
        self._rparen_token = rparen_token
        if rparen_token is not None: 
            rparen_token.register_attachment(self, FunctionDeclarationStmt.rparen_token_slot)
            if rparen_token.has_problems: self._update_has_problems(True)

        assert body is None or FunctionDeclarationStmt.body_slot.accepts(body)
        self._body = body
        if body is not None: 
            body.register_attachment(self, FunctionDeclarationStmt.body_slot)
            if body.has_problems: self._update_has_problems(True)


    @property
    def fct_token(self) -> LeafNode | None:
        """
        The 'fct' token.
        """
        return self._fct_token

    @fct_token.setter
    def fct_token(self, value: LeafNode | None):
        if value is not None: 
            self._fct_token = self.attach_child(self.fct_token_slot, value)
        else:
            self.detach_child(self.fct_token_slot)

    @property
    def name_token(self) -> LeafNode | None:
        """
        The name of the function.
        """
        return self._name_token

    @name_token.setter
    def name_token(self, value: LeafNode | None):
        if value is not None: 
            self._name_token = self.attach_child(self.name_token_slot, value)
        else:
            self.detach_child(self.name_token_slot)

    @property
    def name_token_str(self) -> str:
        """
        The name of the function.
        """
        return self._name_token.text

    @property
    def lparen_token(self) -> LeafNode | None:
        """
        The '(' token.
        """
        return self._lparen_token

    @lparen_token.setter
    def lparen_token(self, value: LeafNode | None):
        if value is not None: 
            self._lparen_token = self.attach_child(self.lparen_token_slot, value)
        else:
            self.detach_child(self.lparen_token_slot)

    @property
    def parameters(self) -> Iterable[FunctionParameter]:
        """
        The parameters of the function.
        """
        return self._parameters

    @property
    def rparen_token(self) -> LeafNode | None:
        """
        The ')' token.
        """
        return self._rparen_token

    @rparen_token.setter
    def rparen_token(self, value: LeafNode | None):
        if value is not None: 
            self._rparen_token = self.attach_child(self.rparen_token_slot, value)
        else:
            self.detach_child(self.rparen_token_slot)

    @property
    def body(self) -> BlockStmt | None:
        """
        The block of statements inside the function.
        """
        return self._body

    @body.setter
    def body(self, value: BlockStmt | None):
        if value is not None: 
            self._body = self.attach_child(self.body_slot, value)
        else:
            self.detach_child(self.body_slot)

    @property
    def children(self):
        if self._fct_token is not None: yield self._fct_token
        if self._name_token is not None: yield self._name_token
        if self._lparen_token is not None: yield self._lparen_token
        yield from self._parameters
        if self._rparen_token is not None: yield self._rparen_token
        if self._body is not None: yield self._body

    @property
    def children_reversed(self):
        if self._body is not None: yield self._body
        if self._rparen_token is not None: yield self._rparen_token
        yield from reversed(self._parameters)
        if self._lparen_token is not None: yield self._lparen_token
        if self._name_token is not None: yield self._name_token
        if self._fct_token is not None: yield self._fct_token

    @property
    def child_inner_nodes(self):
        yield from self._parameters
        if self._body is not None: yield self._body

FunctionDeclarationStmt.element_slots = (FunctionDeclarationStmt.fct_token_slot, FunctionDeclarationStmt.name_token_slot, FunctionDeclarationStmt.lparen_token_slot, FunctionDeclarationStmt.parameters_slot, FunctionDeclarationStmt.rparen_token_slot, FunctionDeclarationStmt.body_slot, )
FunctionDeclarationStmt.inner_node_slots = (FunctionDeclarationStmt.parameters_slot, FunctionDeclarationStmt.body_slot, )


class VariableDeclarationStmt(Statement):
    """
    A variable declaration, with a type, identifier, and optional value.
    """
    __slots__ = ('_type', '_name_token', '_assign_token', '_value', '_semi_colon', )

    type_slot: SingleNodeSlot["VariableDeclarationStmt", BuiltInType] = SingleNodeSlot('_type', BuiltInType)
    "The type of the variable."
    name_token_slot: SingleNodeSlot["VariableDeclarationStmt", LeafNode] = SingleNodeSlot('_name_token', LeafNode, check_func=lambda x: x.kind == TokenKind.IDENTIFIER)
    "The name of the variable."
    assign_token_slot: SingleNodeSlot["VariableDeclarationStmt", LeafNode] = SingleNodeSlot('_assign_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_ASSIGN)
    "The '=' token."
    value_slot: SingleNodeSlot["VariableDeclarationStmt", Expression] = SingleNodeSlot('_value', Expression)
    "The value of the variable."
    semi_colon_slot: SingleNodeSlot["VariableDeclarationStmt", LeafNode] = SingleNodeSlot('_semi_colon', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_SEMICOLON)
    "The ';' token."

    def __init__(self, type: BuiltInType | None, name_token: LeafNode | None, assign_token: LeafNode | None, value: Expression | None, semi_colon: LeafNode | None):
        super().__init__()
        assert type is None or VariableDeclarationStmt.type_slot.accepts(type)
        self._type = type
        if type is not None: 
            type.register_attachment(self, VariableDeclarationStmt.type_slot)
            if type.has_problems: self._update_has_problems(True)

        assert name_token is None or VariableDeclarationStmt.name_token_slot.accepts(name_token)
        self._name_token = name_token
        if name_token is not None: 
            name_token.register_attachment(self, VariableDeclarationStmt.name_token_slot)
            if name_token.has_problems: self._update_has_problems(True)

        assert assign_token is None or VariableDeclarationStmt.assign_token_slot.accepts(assign_token)
        self._assign_token = assign_token
        if assign_token is not None: 
            assign_token.register_attachment(self, VariableDeclarationStmt.assign_token_slot)
            if assign_token.has_problems: self._update_has_problems(True)

        assert value is None or VariableDeclarationStmt.value_slot.accepts(value)
        self._value = value
        if value is not None: 
            value.register_attachment(self, VariableDeclarationStmt.value_slot)
            if value.has_problems: self._update_has_problems(True)

        assert semi_colon is None or VariableDeclarationStmt.semi_colon_slot.accepts(semi_colon)
        self._semi_colon = semi_colon
        if semi_colon is not None: 
            semi_colon.register_attachment(self, VariableDeclarationStmt.semi_colon_slot)
            if semi_colon.has_problems: self._update_has_problems(True)


    @property
    def type(self) -> BuiltInType | None:
        """
        The type of the variable.
        """
        return self._type

    @type.setter
    def type(self, value: BuiltInType | None):
        if value is not None: 
            self._type = self.attach_child(self.type_slot, value)
        else:
            self.detach_child(self.type_slot)

    @property
    def name_token(self) -> LeafNode | None:
        """
        The name of the variable.
        """
        return self._name_token

    @name_token.setter
    def name_token(self, value: LeafNode | None):
        if value is not None: 
            self._name_token = self.attach_child(self.name_token_slot, value)
        else:
            self.detach_child(self.name_token_slot)

    @property
    def name_token_str(self) -> str:
        """
        The name of the variable.
        """
        return self._name_token.text

    @property
    def assign_token(self) -> LeafNode | None:
        """
        The '=' token.
        """
        return self._assign_token

    @assign_token.setter
    def assign_token(self, value: LeafNode | None):
        if value is not None: 
            self._assign_token = self.attach_child(self.assign_token_slot, value)
        else:
            self.detach_child(self.assign_token_slot)

    @property
    def value(self) -> Expression | None:
        """
        The value of the variable.
        """
        return self._value

    @value.setter
    def value(self, value: Expression | None):
        if value is not None: 
            self._value = self.attach_child(self.value_slot, value)
        else:
            self.detach_child(self.value_slot)

    @property
    def semi_colon(self) -> LeafNode | None:
        """
        The ';' token.
        """
        return self._semi_colon

    @semi_colon.setter
    def semi_colon(self, value: LeafNode | None):
        if value is not None: 
            self._semi_colon = self.attach_child(self.semi_colon_slot, value)
        else:
            self.detach_child(self.semi_colon_slot)

    @property
    def children(self):
        if self._type is not None: yield self._type
        if self._name_token is not None: yield self._name_token
        if self._assign_token is not None: yield self._assign_token
        if self._value is not None: yield self._value
        if self._semi_colon is not None: yield self._semi_colon

    @property
    def children_reversed(self):
        if self._semi_colon is not None: yield self._semi_colon
        if self._value is not None: yield self._value
        if self._assign_token is not None: yield self._assign_token
        if self._name_token is not None: yield self._name_token
        if self._type is not None: yield self._type

    @property
    def child_inner_nodes(self):
        if self._type is not None: yield self._type
        if self._value is not None: yield self._value

VariableDeclarationStmt.element_slots = (VariableDeclarationStmt.type_slot, VariableDeclarationStmt.name_token_slot, VariableDeclarationStmt.assign_token_slot, VariableDeclarationStmt.value_slot, VariableDeclarationStmt.semi_colon_slot, )
VariableDeclarationStmt.inner_node_slots = (VariableDeclarationStmt.type_slot, VariableDeclarationStmt.value_slot, )


class ElseStmt(Statement):
    """
    An "else" or "else if" statement. Should be located inside an IfStmt.
    If located somewhere else, it's an error.
    """
    __slots__ = ('_else_token', '_if_token', '_condition', '_block', )

    else_token_slot: SingleNodeSlot["ElseStmt", LeafNode] = SingleNodeSlot('_else_token', LeafNode)
    "The 'else' token."
    if_token_slot: SingleNodeSlot["ElseStmt", LeafNode] = SingleNodeSlot('_if_token', LeafNode)
    "The 'if' token."
    condition_slot: SingleNodeSlot["ElseStmt", Expression] = SingleNodeSlot('_condition', Expression)
    "The condition of the else if statement."
    block_slot: SingleNodeSlot["ElseStmt", BlockStmt] = SingleNodeSlot('_block', BlockStmt)
    "The block of the else if statement."

    def __init__(self, else_token: LeafNode | None, if_token: LeafNode | None, condition: Expression | None, block: BlockStmt | None):
        super().__init__()
        assert else_token is None or ElseStmt.else_token_slot.accepts(else_token)
        self._else_token = else_token
        if else_token is not None: 
            else_token.register_attachment(self, ElseStmt.else_token_slot)
            if else_token.has_problems: self._update_has_problems(True)

        assert if_token is None or ElseStmt.if_token_slot.accepts(if_token)
        self._if_token = if_token
        if if_token is not None: 
            if_token.register_attachment(self, ElseStmt.if_token_slot)
            if if_token.has_problems: self._update_has_problems(True)

        assert condition is None or ElseStmt.condition_slot.accepts(condition)
        self._condition = condition
        if condition is not None: 
            condition.register_attachment(self, ElseStmt.condition_slot)
            if condition.has_problems: self._update_has_problems(True)

        assert block is None or ElseStmt.block_slot.accepts(block)
        self._block = block
        if block is not None: 
            block.register_attachment(self, ElseStmt.block_slot)
            if block.has_problems: self._update_has_problems(True)


    @property
    def else_token(self) -> LeafNode | None:
        """
        The 'else' token.
        """
        return self._else_token

    @else_token.setter
    def else_token(self, value: LeafNode | None):
        if value is not None: 
            self._else_token = self.attach_child(self.else_token_slot, value)
        else:
            self.detach_child(self.else_token_slot)

    @property
    def if_token(self) -> LeafNode | None:
        """
        The 'if' token.
        """
        return self._if_token

    @if_token.setter
    def if_token(self, value: LeafNode | None):
        if value is not None: 
            self._if_token = self.attach_child(self.if_token_slot, value)
        else:
            self.detach_child(self.if_token_slot)

    @property
    def condition(self) -> Expression | None:
        """
        The condition of the else if statement.
        """
        return self._condition

    @condition.setter
    def condition(self, value: Expression | None):
        if value is not None: 
            self._condition = self.attach_child(self.condition_slot, value)
        else:
            self.detach_child(self.condition_slot)

    @property
    def block(self) -> BlockStmt | None:
        """
        The block of the else if statement.
        """
        return self._block

    @block.setter
    def block(self, value: BlockStmt | None):
        if value is not None: 
            self._block = self.attach_child(self.block_slot, value)
        else:
            self.detach_child(self.block_slot)

    @property
    def children(self):
        if self._else_token is not None: yield self._else_token
        if self._if_token is not None: yield self._if_token
        if self._condition is not None: yield self._condition
        if self._block is not None: yield self._block

    @property
    def children_reversed(self):
        if self._block is not None: yield self._block
        if self._condition is not None: yield self._condition
        if self._if_token is not None: yield self._if_token
        if self._else_token is not None: yield self._else_token

    @property
    def child_inner_nodes(self):
        if self._condition is not None: yield self._condition
        if self._block is not None: yield self._block

ElseStmt.element_slots = (ElseStmt.else_token_slot, ElseStmt.if_token_slot, ElseStmt.condition_slot, ElseStmt.block_slot, )
ElseStmt.inner_node_slots = (ElseStmt.condition_slot, ElseStmt.block_slot, )


class IfStmt(Statement):
    """
    An if statement, with [0..N] else/else-if blocks.
    """
    __slots__ = ('_if_token', '_condition', '_then_block', '_else_statements', )

    if_token_slot: SingleNodeSlot["IfStmt", LeafNode] = SingleNodeSlot('_if_token', LeafNode)
    "The 'if' token."
    condition_slot: SingleNodeSlot["IfStmt", Expression] = SingleNodeSlot('_condition', Expression)
    "The condition of the if statement."
    then_block_slot: SingleNodeSlot["IfStmt", BlockStmt] = SingleNodeSlot('_then_block', BlockStmt)
    "The block of the if statement."
    else_statements_slot: MultiNodeSlot["IfStmt", ElseStmt] = MultiNodeSlot('_else_statements', ElseStmt)
    "The else/else-if blocks of the if statement."

    def __init__(self, if_token: LeafNode | None, condition: Expression | None, then_block: BlockStmt | None, else_statements: Iterable[ElseStmt]):
        super().__init__()
        assert if_token is None or IfStmt.if_token_slot.accepts(if_token)
        self._if_token = if_token
        if if_token is not None: 
            if_token.register_attachment(self, IfStmt.if_token_slot)
            if if_token.has_problems: self._update_has_problems(True)

        assert condition is None or IfStmt.condition_slot.accepts(condition)
        self._condition = condition
        if condition is not None: 
            condition.register_attachment(self, IfStmt.condition_slot)
            if condition.has_problems: self._update_has_problems(True)

        assert then_block is None or IfStmt.then_block_slot.accepts(then_block)
        self._then_block = then_block
        if then_block is not None: 
            then_block.register_attachment(self, IfStmt.then_block_slot)
            if then_block.has_problems: self._update_has_problems(True)

        self._else_statements = list(else_statements)
        for s_init_el in self._else_statements:
            assert s_init_el is not None and IfStmt.else_statements_slot.accepts(s_init_el)
            s_init_el.register_attachment(self, IfStmt.else_statements_slot)
            if s_init_el.has_problems: self._update_has_problems(True)


    @property
    def if_token(self) -> LeafNode | None:
        """
        The 'if' token.
        """
        return self._if_token

    @if_token.setter
    def if_token(self, value: LeafNode | None):
        if value is not None: 
            self._if_token = self.attach_child(self.if_token_slot, value)
        else:
            self.detach_child(self.if_token_slot)

    @property
    def condition(self) -> Expression | None:
        """
        The condition of the if statement.
        """
        return self._condition

    @condition.setter
    def condition(self, value: Expression | None):
        if value is not None: 
            self._condition = self.attach_child(self.condition_slot, value)
        else:
            self.detach_child(self.condition_slot)

    @property
    def then_block(self) -> BlockStmt | None:
        """
        The block of the if statement.
        """
        return self._then_block

    @then_block.setter
    def then_block(self, value: BlockStmt | None):
        if value is not None: 
            self._then_block = self.attach_child(self.then_block_slot, value)
        else:
            self.detach_child(self.then_block_slot)

    @property
    def else_statements(self) -> Iterable[ElseStmt]:
        """
        The else/else-if blocks of the if statement.
        """
        return self._else_statements

    @property
    def children(self):
        if self._if_token is not None: yield self._if_token
        if self._condition is not None: yield self._condition
        if self._then_block is not None: yield self._then_block
        yield from self._else_statements

    @property
    def children_reversed(self):
        yield from reversed(self._else_statements)
        if self._then_block is not None: yield self._then_block
        if self._condition is not None: yield self._condition
        if self._if_token is not None: yield self._if_token

    @property
    def child_inner_nodes(self):
        if self._condition is not None: yield self._condition
        if self._then_block is not None: yield self._then_block
        yield from self._else_statements

IfStmt.element_slots = (IfStmt.if_token_slot, IfStmt.condition_slot, IfStmt.then_block_slot, IfStmt.else_statements_slot, )
IfStmt.inner_node_slots = (IfStmt.condition_slot, IfStmt.then_block_slot, IfStmt.else_statements_slot, )


class WhileStmt(Statement):
    """
    A while loop, with a condition and a block of statements to run while the condition is true.
    """
    __slots__ = ('_while_token', '_condition', '_block', )

    while_token_slot: SingleNodeSlot["WhileStmt", LeafNode] = SingleNodeSlot('_while_token', LeafNode)
    "The 'while' token."
    condition_slot: SingleNodeSlot["WhileStmt", Expression] = SingleNodeSlot('_condition', Expression)
    "The condition to check before running the block."
    block_slot: SingleNodeSlot["WhileStmt", BlockStmt] = SingleNodeSlot('_block', BlockStmt)
    "The block of statements to run while the condition is true."

    def __init__(self, while_token: LeafNode | None, condition: Expression | None, block: BlockStmt | None):
        super().__init__()
        assert while_token is None or WhileStmt.while_token_slot.accepts(while_token)
        self._while_token = while_token
        if while_token is not None: 
            while_token.register_attachment(self, WhileStmt.while_token_slot)
            if while_token.has_problems: self._update_has_problems(True)

        assert condition is None or WhileStmt.condition_slot.accepts(condition)
        self._condition = condition
        if condition is not None: 
            condition.register_attachment(self, WhileStmt.condition_slot)
            if condition.has_problems: self._update_has_problems(True)

        assert block is None or WhileStmt.block_slot.accepts(block)
        self._block = block
        if block is not None: 
            block.register_attachment(self, WhileStmt.block_slot)
            if block.has_problems: self._update_has_problems(True)


    @property
    def while_token(self) -> LeafNode | None:
        """
        The 'while' token.
        """
        return self._while_token

    @while_token.setter
    def while_token(self, value: LeafNode | None):
        if value is not None: 
            self._while_token = self.attach_child(self.while_token_slot, value)
        else:
            self.detach_child(self.while_token_slot)

    @property
    def condition(self) -> Expression | None:
        """
        The condition to check before running the block.
        """
        return self._condition

    @condition.setter
    def condition(self, value: Expression | None):
        if value is not None: 
            self._condition = self.attach_child(self.condition_slot, value)
        else:
            self.detach_child(self.condition_slot)

    @property
    def block(self) -> BlockStmt | None:
        """
        The block of statements to run while the condition is true.
        """
        return self._block

    @block.setter
    def block(self, value: BlockStmt | None):
        if value is not None: 
            self._block = self.attach_child(self.block_slot, value)
        else:
            self.detach_child(self.block_slot)

    @property
    def children(self):
        if self._while_token is not None: yield self._while_token
        if self._condition is not None: yield self._condition
        if self._block is not None: yield self._block

    @property
    def children_reversed(self):
        if self._block is not None: yield self._block
        if self._condition is not None: yield self._condition
        if self._while_token is not None: yield self._while_token

    @property
    def child_inner_nodes(self):
        if self._condition is not None: yield self._condition
        if self._block is not None: yield self._block

WhileStmt.element_slots = (WhileStmt.while_token_slot, WhileStmt.condition_slot, WhileStmt.block_slot, )
WhileStmt.inner_node_slots = (WhileStmt.condition_slot, WhileStmt.block_slot, )


class FunctionCallStmt(Statement):
    """
    A function call statement, which just contains a function call expression, and discards the
    return value of the function.
    """
    __slots__ = ('_expr', '_semi_colon', )

    expr_slot: SingleNodeSlot["FunctionCallStmt", FunctionExpr] = SingleNodeSlot('_expr', FunctionExpr)
    "The function call expression."
    semi_colon_slot: SingleNodeSlot["FunctionCallStmt", LeafNode] = SingleNodeSlot('_semi_colon', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_SEMICOLON)
    "The ';' token."

    def __init__(self, expr: FunctionExpr | None, semi_colon: LeafNode | None):
        super().__init__()
        assert expr is None or FunctionCallStmt.expr_slot.accepts(expr)
        self._expr = expr
        if expr is not None: 
            expr.register_attachment(self, FunctionCallStmt.expr_slot)
            if expr.has_problems: self._update_has_problems(True)

        assert semi_colon is None or FunctionCallStmt.semi_colon_slot.accepts(semi_colon)
        self._semi_colon = semi_colon
        if semi_colon is not None: 
            semi_colon.register_attachment(self, FunctionCallStmt.semi_colon_slot)
            if semi_colon.has_problems: self._update_has_problems(True)


    @property
    def expr(self) -> FunctionExpr | None:
        """
        The function call expression.
        """
        return self._expr

    @expr.setter
    def expr(self, value: FunctionExpr | None):
        if value is not None: 
            self._expr = self.attach_child(self.expr_slot, value)
        else:
            self.detach_child(self.expr_slot)

    @property
    def semi_colon(self) -> LeafNode | None:
        """
        The ';' token.
        """
        return self._semi_colon

    @semi_colon.setter
    def semi_colon(self, value: LeafNode | None):
        if value is not None: 
            self._semi_colon = self.attach_child(self.semi_colon_slot, value)
        else:
            self.detach_child(self.semi_colon_slot)

    @property
    def children(self):
        if self._expr is not None: yield self._expr
        if self._semi_colon is not None: yield self._semi_colon

    @property
    def children_reversed(self):
        if self._semi_colon is not None: yield self._semi_colon
        if self._expr is not None: yield self._expr

    @property
    def child_inner_nodes(self):
        if self._expr is not None: yield self._expr

FunctionCallStmt.element_slots = (FunctionCallStmt.expr_slot, FunctionCallStmt.semi_colon_slot, )
FunctionCallStmt.inner_node_slots = (FunctionCallStmt.expr_slot, )


class AssignStmt(Statement):
    """
    A variable assignment statement, which assigns a value to an existing variable.
    """
    __slots__ = ('_name_token', '_assign_token', '_value', '_semi_colon', )

    name_token_slot: SingleNodeSlot["AssignStmt", LeafNode] = SingleNodeSlot('_name_token', LeafNode, check_func=lambda x: x.kind == TokenKind.IDENTIFIER)
    "The name of the variable."
    assign_token_slot: SingleNodeSlot["AssignStmt", LeafNode] = SingleNodeSlot('_assign_token', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_ASSIGN)
    "The '=' token."
    value_slot: SingleNodeSlot["AssignStmt", Expression] = SingleNodeSlot('_value', Expression)
    "The value to assign to the variable."
    semi_colon_slot: SingleNodeSlot["AssignStmt", LeafNode] = SingleNodeSlot('_semi_colon', LeafNode, check_func=lambda x: x.kind == TokenKind.SYM_SEMICOLON)
    "The ';' token."

    def __init__(self, name_token: LeafNode | None, assign_token: LeafNode | None, value: Expression | None, semi_colon: LeafNode | None):
        super().__init__()
        assert name_token is None or AssignStmt.name_token_slot.accepts(name_token)
        self._name_token = name_token
        if name_token is not None: 
            name_token.register_attachment(self, AssignStmt.name_token_slot)
            if name_token.has_problems: self._update_has_problems(True)

        assert assign_token is None or AssignStmt.assign_token_slot.accepts(assign_token)
        self._assign_token = assign_token
        if assign_token is not None: 
            assign_token.register_attachment(self, AssignStmt.assign_token_slot)
            if assign_token.has_problems: self._update_has_problems(True)

        assert value is None or AssignStmt.value_slot.accepts(value)
        self._value = value
        if value is not None: 
            value.register_attachment(self, AssignStmt.value_slot)
            if value.has_problems: self._update_has_problems(True)

        assert semi_colon is None or AssignStmt.semi_colon_slot.accepts(semi_colon)
        self._semi_colon = semi_colon
        if semi_colon is not None: 
            semi_colon.register_attachment(self, AssignStmt.semi_colon_slot)
            if semi_colon.has_problems: self._update_has_problems(True)


    @property
    def name_token(self) -> LeafNode | None:
        """
        The name of the variable.
        """
        return self._name_token

    @name_token.setter
    def name_token(self, value: LeafNode | None):
        if value is not None: 
            self._name_token = self.attach_child(self.name_token_slot, value)
        else:
            self.detach_child(self.name_token_slot)

    @property
    def name_token_str(self) -> str:
        """
        The name of the variable.
        """
        return self._name_token.text

    @property
    def assign_token(self) -> LeafNode | None:
        """
        The '=' token.
        """
        return self._assign_token

    @assign_token.setter
    def assign_token(self, value: LeafNode | None):
        if value is not None: 
            self._assign_token = self.attach_child(self.assign_token_slot, value)
        else:
            self.detach_child(self.assign_token_slot)

    @property
    def value(self) -> Expression | None:
        """
        The value to assign to the variable.
        """
        return self._value

    @value.setter
    def value(self, value: Expression | None):
        if value is not None: 
            self._value = self.attach_child(self.value_slot, value)
        else:
            self.detach_child(self.value_slot)

    @property
    def semi_colon(self) -> LeafNode | None:
        """
        The ';' token.
        """
        return self._semi_colon

    @semi_colon.setter
    def semi_colon(self, value: LeafNode | None):
        if value is not None: 
            self._semi_colon = self.attach_child(self.semi_colon_slot, value)
        else:
            self.detach_child(self.semi_colon_slot)

    @property
    def children(self):
        if self._name_token is not None: yield self._name_token
        if self._assign_token is not None: yield self._assign_token
        if self._value is not None: yield self._value
        if self._semi_colon is not None: yield self._semi_colon

    @property
    def children_reversed(self):
        if self._semi_colon is not None: yield self._semi_colon
        if self._value is not None: yield self._value
        if self._assign_token is not None: yield self._assign_token
        if self._name_token is not None: yield self._name_token

    @property
    def child_inner_nodes(self):
        if self._value is not None: yield self._value

AssignStmt.element_slots = (AssignStmt.name_token_slot, AssignStmt.assign_token_slot, AssignStmt.value_slot, AssignStmt.semi_colon_slot, )
AssignStmt.inner_node_slots = (AssignStmt.value_slot, )


class ErrorStmt(Statement):
    """
    An invalid/unrecognized statement. Prevents compilation.
    """
    __slots__ = ('_tokens', )

    tokens_slot: MultiNodeSlot["ErrorStmt", LeafNode] = MultiNodeSlot('_tokens', LeafNode)
    "All tokens that were ignored during parsing."

    def __init__(self, tokens: Iterable[LeafNode]):
        super().__init__()
        self._tokens = list(tokens)
        for s_init_el in self._tokens:
            assert s_init_el is not None and ErrorStmt.tokens_slot.accepts(s_init_el)
            s_init_el.register_attachment(self, ErrorStmt.tokens_slot)
            if s_init_el.has_problems: self._update_has_problems(True)


    @property
    def tokens(self) -> Iterable[LeafNode]:
        """
        All tokens that were ignored during parsing.
        """
        return self._tokens

    @property
    def children(self):
        yield from self._tokens

    @property
    def children_reversed(self):
        yield from reversed(self._tokens)

    @property
    def child_inner_nodes(self):
        return []

ErrorStmt.element_slots = (ErrorStmt.tokens_slot, )
ErrorStmt.inner_node_slots = ()


